/ *! jQuery v1.10.2 | (c) 2005, 2013 jQuery Fundación, Inc. | jquery.org / licencia

/ / @ SourceMappingURL = jquery-1.10.2.min.map

* /

(Function (e, t) {var n, r, i = typeof nuevo i, o, si (! e) Retorno Este; if ("string" == typeof instanceof n) x.isFunction (esta [i]), este [i] (n [i]):? this.attr (i, n [i]);} devolver este caso (o = a.getElementById (i [2 ]), o && o.parentNode) {if (i == o.id [2]) r.find retorno (e);! this.length = 1, este [0] = o} return this.context = a, este . selector = e, esto} return g.call (this)}, obtener: la función (e) {return null == e this.toArray (): 0> e esta [this.length + e]: esta [e]}, pushStack: function ( e) {var t = x.merge (this.constructor (), e); volver t.prevObject = esto, t.context = this.context, t}, cada uno: function (e, t) {x.each retorno (esto, e, t)}, lista: function (e) {return x.ready.promise () hecho (e), esto}, rebanada:. función () {return this.pushStack (g.apply (esto, argumentos))}, primero: function () {return this.eq (0)}, último: function () {return this.eq (-1)}, eq: function (e) {var t = this.length, n = + e + (0> e t: 0); volver this.pushStack (n> = 0 && t> n [esta [n]]: []?)}, mapa: function (e) {return this.pushStack ( x.map (this, function (t, n) {return e.call (t, n, t)}))}, final: function () {return e, n, r, i, o, a, s = argumentos [0] | | {}, l = 1, u = arguments.length, c = 1;! de ("booleano" == typeof s && (c = s, s = argumentos [1] | | {}, l = 2), "objeto" == typeof S | | x.isFunction (s) | | (s = {}), u === l && (s = esto, - l); u> l; l + +) if (NULL! = (o = argumentos [l])) para (i en s}, x.extend ({expando:. "jQuery" + (f + Math.random ()) replace (/ \ / D g, ""), noConflict: function (t) {return ? == null e e + "": "objeto" == typeof e | | "función" == typeof e c [y.call (e)] | |? "objeto": typeof e}, isPlainObject: function (e ) {var en e) v.call retorno (e, n), para (n en e); regresar n === T | | v.call (e, n)}, isEmptyObject: function (e) {var t; for ( t en e) return 1;} return 0, error: function (e) {Error throw (e)}, ParseHTML: function (e, t, n) {if (e | | "cadena" = typeof!! e) return null; "booleano" == typeof t && (n = t, t = 1), t = t | | a;! var r = k.exec (e), i = n && []; retorno ? e.JSON && e.JSON.parse e.JSON.parse (n): null === n n:? "cadena" == typeof n && (n = x.trim (n), n && E.test (n.replace ( .. A, "@") reemplazar (j, "]") reemplazará (S, ""))) Función (? "retorno" + n) (): (x.error ("JSON válido:" + n) , t)}, parseXML: function (n) {var r, i, si (N | | = typeof n) return null "cadena"; try {e.DOMParser (i = new DOMParser, r = i!?. parseFromString (n, "text / xml")): (r = new ActiveXObject ("Microsoft.XMLDOM"), r.async = "false", r.loadXML (n))} catch (o) {r = t} volver r && longitud r.documentElement && r.getElementsByTagName ("ParserError") | | x.error ("XML no válido!.: e.replace (D, "ms") reemplazará (L, H)}, nodeName:. función (e, t) {return e.nodeName && e.nodeName.toLowerCase () === t.toLowerCase ()}, cada uno : function (e, t, n) {var r, i = 0, o = e.length, a = M (e); if (n) {if (a) {for (; o> i; i + +) si (r = t.apply (e [i], n), r ===! 1) Salto} else for (i en e) si (r = t.apply (e [i], n), r == ! = 1) break} else if (a) {for (; o> i; i + +) if (r = T.CALL (e [i], i, e [i]), r === 1) Salto! } else for (i en e) si (r = T.CALL (e [i], i, e [i]), r === 1!) break; regresar e}, recorte: b && b.call ( ? "\ ufeff \ u00a0") función (e) {return null == e "?": b.call (e)}: function (e) {return null == e? "": (e + ""). replace (C, "")}, MakeArray: function (e, t) {var n = t | | []; devolver null && = e (M (Object (e)) x.merge (n,? "cadena" ? == typeof e [e]: e): h.call (n, e)), n}, inArray: function (e, t, n) {var r: si (t) {if (m) return m . llame al (t, e, n), para (r = T.Length, n = n 0> n Math.max (0, r + n): n:?? 0, r> n, n + +) if (n en t && t [n] === e) return n} return-1}, fusionar: function (e, n) {var r = n.length, i = e.length, o = 0; if ("número" = = typeof r) for (; r> o; o + +) e [i + +] = n [o]; cosa mientras (n [o] == t) e [i + +] = n [o + +];! devolver e.length = i, e}, grep:; (¡n = n; a> o; o + +) función (e, t, n) {var r, i = [], o = 0, a = e.length para r = ¡¡¡t (e [o], o), n == r && i.push (e [o]); return i}, mapa: function (e, t, n) {var r, i = 0, o = e.length, a = M (e), s = []; si (a) for (; o> i; i + +)! r = t (e [i], i, n), null = r && (s [ s.length] = r); más para (i en e) r = t (e [i], i, n), null = r && (s [s.length] = r);! devolver d.apply ([ ], s)}, guid: 1, Proxy: function (e, n) {var r, i, o, vuelva "cadena" == typeof n && (o = e [n], n = e, e = o) , x.isFunction (e)? (r = g.call (argumentos, 2), i = function () {return l = 0, u = e.length, c = null == r; if ("objeto" === x.type (r)) {o = 0;! de (l en r) x.access (e, ! n, l, r [l], 0, a, s)} else if (i! == t && (o = 0, x.isFunction (i) | |! (s = 0), c && (s? (n.call (e, i), n = null): (c = n, n = función (E, T, N) {return c.call (x (e), n)})), n)) for (; u> l; l + +) n (e [l], r, s i:? i.call (e [l], l, n (e [l], r))); o declaración electrónica?: ? c n.call (e):? u n (e [0], r): a}, ahora:. function () {return (nueva fecha) getTime ()}, canje: function (e, t, n , r) {var i, o, a = {}; para (o en t) a [o] = e.style [o], e.style [o] = t [o], i = n.apply ( e, r | | []), por (o en t) e.style [o] = a [o]; retorno ! r = 1; try {r = null && == e.frameElement a.documentElement} catch (i) {} r && r.doScroll && función o () {if (! x.isReady) {try {r.doScroll ("izquierda")} catch (e) {return setTimeout (o, 50)} _ (), x.ready ()}} ()} return n.promise (t)}, x.each ("Número de Boole Cadena función array Fecha RegExp objeto Error . "split (" "), la función (e, t) {c [" [object "+ t +"] "] = t.toLowerCase ()}); función M (e) {var t = e.length, n ?! = x.type (e); volver x.isWindow (e) 01:01 === e.nodeType && t 0: "array" === n | | "función" == n && (0 ==?! = t | | "número" == typeof t && t> 0 && t-1 en e)} r = x (a), la función (e, t) {var n, r, i, o, a, s, l, u, c, p, f, d, h, g, m, y, v, b = "chisporroteo" + nuevo Fecha, w = e.document, T = 0, C = 0, N = st (), k = ! st (), E = st (), S = 1, A = function (e, t) {return e === t (S = 0,0!): 0}, j = typeof t, D = 1 << 31, L = {} hasOwnProperty, H = [], q = H.pop, _ = H.push, M = H.push, O = H.slice, F = H.indexOf |. | función ( e) {var t = 0, n = this.length; for (; n> t; t + +) if (esta [t] === e) retorno r = "0 x" + t-65536; retorno n = e.length, r = 0, mientras que (e [n + +] = t [r + +]); e.length = n-1}}} function a (e, t, n, i) {var O, A, s, l, u, c, d, m, y, x; if ((t t.ownerDocument | | t:?! w) == f && p (t), t = T | | f, n = N | | [], e | |! "cadena" = typeof e) retorno n; if (a.id === s) return n.push (a), n} else if (t.ownerDocument && (a = t.ownerDocument.getElementById (s)) && v (t, a) && a.id = == s) n.push retorno (a), n} else {if (o [2]) return ", U = c.length, mientras que (u -) c [u] = m + yt (c [u]); y = V.test (e) && t.parentNode | | t, x = c.join ( ",")} if (x) try {volver M.apply (n, y.querySelectorAll (x)), n} catch (T) {} finally {d | | t.removeAttribute ("id")}}} volver kt (e.replace (z "$ 1"), t, n, i)} function st () {var e = []; función de t (n, r) {return e.push (n + = "") > o.cacheLength && eliminar t [e.shift ()], t [n] = r} return t función} lt (e) {return e [b] = 0, e} function ut (e) {var ct (e, t) {var n = e.split ("|"), r = e.length, mientras que (r -) o.attrHandle [n [r]] = t} function pt (e, t) {var n = t && e, r = n && 1 === e.nodeType && 1 === t.nodeType && (~ t.sourceIndex | | D) - (~ e.sourceIndex | | D); if (r) r retorno; if ( n) while (n = n.nextSibling) if (n === t) return-1; regresar e 1: -1} function pies (e) {retorno de la función (t) {var n = t.nodeName.toLowerCase (); retorno "de entrada" === n && Ttipo === e}} function dt (e) {retorno de la función (t) {var n = t.nodeName.toLowerCase (); return ("input" === n | | "botón" === n) && Ttipo === e}} function ht (e) {return lt (function (t) {return t = + t, lt (function (n, r) {var t = e && (e.ownerDocument | | e) documentElement; retorno t "HTML" == t.nodeName:.?!! 1}, r = at.support = {}, p = at.setDocument = function (e) {var n = e e.ownerDocument | | e: w, i = n.defaultView; retorno e.className = "i",! e.getAttribute ("className")}), r.getElementsByTagName = ut (function (e) {return e.innerHTML = "<div class='a'> </ div> <div class = 'a ! t.getElementById == j && h) {var n = t.getElementById (e); retorno && n n.parentNode [n]: []?}}, o.filter.ID = function (e) {var t = e.replace (rt, ello); función de retorno (e) {return e.getAttribute ("id") === t}}): (eliminar o.find.ID, o.filter.ID = function (e) {var t = e.replace (rt, ello); función de retorno (e) {var n = typeof e.getAttributeNode == j && e.getAttributeNode ("id");! retorno && n n.value === t}}), o.find .? TAG = function r.getElementsByTagName (e, n) {return typeof n.getElementsByTagName == j n.getElementsByTagName (e):? t}: function (e, t) {var n, r = [], i = 0, o = t.getElementsByTagName (e); if ("*" === e) {while (n = o [i + +]) 1 === n.nodeType && r.push (n); retorno r} buscar o }, o.find.CLASS = r.getElementsByClassName && función (e, n) {typeof retorno n = 9 === e.nodeType e.documentElement: e, r = t && t.parentNode; retorno S = 0,0;! Var i = t.compareDocumentPosition && e.compareDocumentPosition && e.compareDocumentPosition (t); retorno r, i = 0, o = e.parentNode, a = t.parentNode, s = [e] l = [t];! if (e === t) return S = 0,0;! if (o | | a) la devolución e === N -1:????? t === n 1: o -1: a 1: c F.call (c, e)-F.call (c, t ): 0; si (o === a) la devolución ? i pt (s [i], l [i]): s [i] === w -1:?? l [i] === w 1:00}, n): f}, at.matches = function (e, t) {return n = y.call (e, t); if (! n | | r.disconnectedMatch | | e.document && 11 == e.document.nodeType) return n} catch (i) {} return ? i = o.attrHandle [n.toLowerCase ()], a = i && L.call (o.attrHandle, n.toLowerCase ()) i (¡e, n, h): t; retorno Error ("Error de sintaxis, la expresión no reconocida:" + e)}, at.uniqueSort = function (e) {var e}, a = at.getText = function (e) {var t, n = "", r = 0, i = e.nodeType, si (i) {if (1 === i | | 9 === i | | 11 === i) {if ("string" == typeof e.textContent) devuelven e.textContent; for (e = e.firstChild; e; e = e.nextSibling) n + = a (e)} else if (3 === I | | 4 === i) devuélvalo e.nodeValue} else for (; t = e [r]; r + +) + n = a (t); retorno . e [1] = e [1] reemplazará (rt, ella), e [3] = (e [4] | | e [5] | | "") reemplazará (rt, it),. "~ =" === e [2] && (e [3] = "" + e [3] + ""), e.slice (0,4)}, NIÑO: function (e) {return ! n, r = e [5] && e [2]; retorno .? t = e.replace (rt, it) toLowerCase (); return "*" === function () {! return 0} e: function (e) {return e.nodeName && e.nodeName.toLowerCase () == = t}}, CLASE: function (e) {var t = N [t + ""]; retorno T | | (t = RegExp ("(^ |" + P + ")" + e + "(" + P + "| $) ")) && N (e, función (e) {return t.test (" string "== typeof e.className && e.className | | typeof e.getAttribute == j && e.getAttribute (" clase ") | |" ")})}, ATTR: function (e, t, n) {function de retorno (r) {var i = at.attr (r, e); retorno "+ I +" ¡o = "enésimo" == e.slice (0,3), a = "último" == e.slice (-4), s = "del tipo" === t, y devuelve 1 === ? r && 0 === función i (e) {return e.parentNode!}: function (t, n, l) {var if (v && (u = (t [b] | | (t [b] = {})) [e]) && u [0] === T) f = u [1], de otra f-= i, f === r | | 0 === f% r && f / r> = 0}}}, PSEUDO: function (e, t) {var n, r = o.pseudos [e] | | o.setFilters [e.toLowerCase ()] | | at.error ("pseudo no soportado:" + e);?? r retorno [b] r (t): r.length> 1 (n = [e, e, "", t], o.setFilters.hasOwnProperty (e.toLowerCase ()) lt (function (e, n) {var i, o = r (e, t), a = o.length;? mientras que (a- -) i = F.call (e, o [a]), e [i] = (n [i] = o [a])}): function (e) {return r (e, 0, n) }): r}}, pseudos: {No: lt (function (e) {var t = [], n = [], r = l (e.replace (z "$ 1")); retorno r [b ?] lt (function (e, t, n, i) {var o, a = r (e, null, i, []), s = e.length, mientras que (s -) (o = a [s ]) && (e [s] = (t [s] = o!))}): function (e, i, o) {return t [0] = e, r (t, nulo, o, n), ! n.pop ()}}), cuenta con:. lt (function (e) {retorno de la función (t) {return a (e, t) de longitud> 0}}), contiene: lt (function (e) {return función (t) {return (t.textContent | | t.innerText | | a (t)) indexOf (e)> -1.}}), lang: lt (function (e) {return G.test (e | | "") | | at.error ("sin apoyo lang:.?" + e), e = e.replace (rt, it) toLowerCase (), la función (t) {var n; hacer si (n = h t . lang: t.getAttribute ("xml: lang") | | t.getAttribute ("lang")) return n = e.location && e.location.hash; retorno n && n.slice (1) === t.id}, raíz: function (e) {return e === d}, el enfoque: function (e) {return e.disabled === 1}, discapacitados: ¡función (e) {return e.disabled === 0}, comprobado: function (e) {var tt.test (e.nodeName)}, de entrada: function (e) {return et.test (e.nodeName)}, un botón: function (e) {var t = e.nodeName.toLowerCase (); volver "entrada" === t && "botón" === e.type | | "botón" === t}, el texto: function (e) {var n = 0; for (; t> n, n + = 2) e.push (n), e regresar}), impar: ht (function (e, t) {var n = 1; for (; t> n; n + = 2) e.push (n); volver e}), lt: ht (function (e, t, n) {var r = 0> n n + t: n; for (; - r> = 0 ;) e.push (r); volver e}), gt:? ht (function (e, t, n) {var r = 0> n n + t: n; for (; t> + + r; ) e.push (r); volver e})}}, o.pseudos.nth = o.pseudos.eq; for (n en {radio: ¡¡¡0, casilla: 0, file: 0, contraseña: 0, image: 0}) o.pseudos [n] = m (n); para (n en {someten: 0, reset: ¡0}) o.pseudos [n] = dt (n); función gt () {} gt.prototype = o.filters = o.pseudos, o.setFilters = new gt; función mt (e, t) {var n, r, i, a, s, l, u, c = k [ e + ""]; if (c) la devolución ")}), S = s.slice (n.length)), porque (a en la ??. t s.length: s at.error (e): k (e, l) slice (0)} function yt (e) {var t = 0, n = e.length, r = ""; para (; n> t; t + +) r + = e [l] valor;. retorno r} function vt (e, t, n) {var r = t.dir, o = n && "parentNode" === r, a = C + +; volver t.first función (t, n, i) {while (t = t [r]) si (1 === t.nodeType | | o) la devolución e (t, n, i)}: función? (t, n, s) {var l, u, c, p = T + "" + a; if (s) {while (t = t [r]) if ((1 === t.nodeType | | o ) && e (t, n, s)) return 0} else l === 0} else if (u = c [r] = [p], u [1] = e (t, n, s) | |! i, u [1] === 0)! regresan! ? 0}} function bt (e) {e.length retorno> 1 función (t, n, r) {var i = e.length;! while (i -) si (e [i] (t, n, r)) return 1;} return 0: ¡e [0]} function xt (e, t, n, r, i) {var a} en peso de la función (e, t, n, r, i, o) {return r &&! r [b] && (r = p (r)), i &&! i [b] && (i = p (i, o )), lt (function (o, a, s, l) {var y = xt (y === una y.splice (h, y.length):? y), i i (null, una, y, l):?})} function M.apply (a, y) Tt (e) {var t, n, r, i = e.length, a = o.relative [e [0] Tipo.], s = a | | o.relative [""], l = a 1?: 0, c = vt (function (e) {return e === t}, s, 0), p = vt (function (e) {return . p (l> 1 && bt (f), l> 1 && yt (e.slice (0, l-1) concat ({valor: " BT (f)} la función de Ct (e, t) {var n = 0, R = T.Length> 0, a = e.length> 0, s = función (s, L, C, P, D) {var w && (T = k, u = C), x}; retorno r lt (s): s} l = at.compile = function (e, t) {var n, r = [], i = [], o = E [e + " o}; función Nt (e, t, n) {var r = 0, i = T.Length; for (; i> r, r + +) a (e, t [r], n); retorno n} function kt (e, t, n, i) {var M.apply (n, i), n; break}}} return 1 & e.compareDocumentPosition (f.createElement ("div"))}), ut (function (e) {return e.innerHTML = "<a r t:? e.getAttribute (n, "tipo" === n.toLowerCase () 01:02?)}), r.attributes && ut (function (e) {return r | | "entrada" == e.nodeName.toLowerCase () t:? e.defaultValue}), ut (function (e) {return null == e.getAttribute ("disabled")}) | | ct ( B, función (e, n, r) {var i; retorno O = {}; función F (e) {var t = O [e] = {}; retorno x.each (e.match (T) | | [], la función (e, n) {t [n] = ! 0}), t} x.Callbacks = function (e) {e = "cadena" == typeof e O [e] | | F (e):? x.extend ({}, e); var t = l.length; (función i (t) {x.each (t, la función (t, n) {var esto}, remover: function () {return l && x.each (argumentos, la función (e, t) {var e x.inArray (e, l)> -1: (l | | l.length!)}, vacía:?! función () {return l = [], o = 0,}, deshabilite: function ( ) {return l = u = r = t, esto}, discapacitados: function () {return l!}, bloqueo: function () {return p.fireWith (este, argumentos), esto}, disparó: function () {return i}}; retorno p}, x.extend ({diferido: ¡función (e) {var t = [["determinación", "Hecho", x.Callbacks ("una vez que la memoria"), "resueltos"], ["rechazar", "FAIL", x.Callbacks ("una vez . n}, siempre: function () {return i.done (argumentos) FAIL (argumentos), esto}, a continuación: function () {var e = argumentos; volver x.Deferred (function (n) {x.each ( t, la función (t, o) {var a = o [0], s = x.isFunction (e [l]) && e [l]; i [o [1]] (function () {var ? null = x.extend e (e, r): r}}, i = {}; retorno r.pipe = r.then, x.each (t, la función (e, o) {var i | | o.resolveWith (u, n), o.promise ()}}), x.support = function (t) {var n, r, o, s, l, u, c, p, f, d = a.createElement ("div"); if (d.setAttribute ("className", "t"), d.innerHTML = "<link/> <table> </ table> <a href='/a'> un </ a> <de entrada en {presentar: 0, cambie: 0, focusin: 0}) d.setAttribute (c = "en" + f, "t"), t [f + "Burbujas"] = c en en x (t)) break; volver t.ownLast = "0" == f, x (function () {var!

} ({}); Var B = / (: \ {[\ s \ S] * \} | \ [[\ s \ S] * \]) $ /, = P / ([AZ]) / g ; función R (e, n, r, i) {if (x.acceptData (e)) {var n) return c | | (c = l e [s] = p.pop (?) | | x.guid + +: s), u [c] | | (u [c] = l {}: {toJSON: x.noop}), ("objeto" == typeof n | | "función" == typeof n (o = a [n], null == o && (o = a [x.camelCase (n)])):? o = a, o}} function W (e, t, n) {if (x. acceptData (e)) {var ? en r t = [t]: (¿t = x.camelCase (t), t = t en r [t]: t.split ("")), i = T.Length, mientras que (i -) eliminar r [t [i]] if (n I (r):?! x.isEmptyObject (r)). retorno} (n | | (eliminar una [s] de datos, I (a [s])) ) && (o x.cleanData ([e], 0?):? x.support.deleteExpando | | a = a.window borrar ? e = e.nodeType x.cache [e [x.expando]]: ¡¡¡e [x.expando], e && I (e)}, los datos: function (e, t, n) {return R (e , t, n)}, REMOVEDATA: function (e, t) {return W (e, t)}, _data: función (e, t, n) {return R (e, t, n, 0)}, _removeData: function (e, t) {return W (e, t, 0!)}, acceptData: función (e) {if (! e.nodeType && 1 == e.nodeType && 9 == e.nodeType) return 1; var o} return "objeto" == typeof this.each (function () {x.removeData (esto, e)})}}); función $ (e, n, r) {if (r === t && 1 === e.nodeType) {var i = "datos" + n.replace (P ", - $ 1") toLowerCase ();. if (r = e.getAttribute (i), "cadena" == typeof r = t} return r} function I (e) {var t; para (t en i; retorno O.Stop, i.call (e, a, o)), r && o && o.empty.fire ()}, _queueHooks: función (e, t) {var n = t + "queueHooks"; retorno x._data (e, n) | | x._data (e, n, {vacías: x.Callbacks ("una vez ? r = 2; retorno "cadena" = typeof e && (n = e, e = "fx", r -), r> arguments.length x.queue (esto [0], e): n === t esto:? this.each (function () {var ? this.each (function () {x.dequeue (esto, e)})}, delay: function (e, t) {return e = x.fx x.fx.speeds [e] | | e: e, t = t | | "fx", this.queue (t, la función (t, n) {var r = setTimeout (t, e); n.stop = function () {clearTimeout (r)}})}, clearQueue : function (e) {return this.queue (e | | "fx", [])}, la promesa: function (e, n) {var r, i = 1, o = x.Deferred (), a = esta , s = this.length, l = function () {- I | | o.resolveWith (a, [a])};! "cadena" = typeof L (), o.promise (n)}}); var x.access (esto, x.attr, e, t, arguments.length> 1)}, removeAttr: function (e) {return this.each (function () {x.removeAttr (esto, e)})}, prop: function (e, t) {return x.access (esto, x.prop, e, t, arguments.length> 1)}, removeProp: function (e) {return e = x.propFix [e] | | e, this.each (function () {try {este [e] = t, eliminar este [e]} catch (n) {}})}, addClass: function (e) {var t, n, r, i , o, a = 0, s = this.length, l = "cadena" == typeof e && e; if (x.isFunction (e)) return . "+ N.className +" ") reemplazar (U," "):" ")) {o = 0, mientras que (i = t [o + +]) 0> r.indexOf (" "+ i +" ") && ( r = + i + ""); n.className = x.trim (r)}} devolver este, removeClass: function (e) {var t, n, r, i, o, a = 0, s = this.length, l = 0 === arguments.length | | "cadena" == typeof e && e; if (x.isFunction (e)) return . "+ N.className +" ") reemplazar (U," "):" ")) {o = 0, mientras que (i = t [o + +]), mientras que (r.indexOf (" "+ i +" ")> = 0) r = r.replace ("" + i + "", ""); n.className = e x.trim (r): ""}} devuelva este, toggleClass: function (e, t) {var n = typeof e; retorno "boolean" == typeof t = "" + e + "", n = 0, r = this.length; for (; r> n, n + +).. si (1 === esta [n] nodeType && ("" + esta [n] className + . "".) reemplazar (U, "") indexOf (t)> = 0) return 0;} return 1, val: ¡función (e) {var n, r, i, o = esta [0]; {if (arguments.length) return i = x.isFunction (e), this.each (function (n) {var s;? 1 === this.nodeType && (o = i e.call (este, n, x . (este) val ()):? e, null == o o = "": "número" == typeof o o + = "": x.isArray (o) && (o = x.map (o, función (e) {? return null == e "": e + ""})), r = x.valHooks [this.type] | | [x.valHooks this.nodeName.toLowerCase ()], r && "set" en r && R.SET (esto, o, "valor") == T | | (this.value = o))});! si (o) de retorno R = x.valHooks [o.type] | | x.valHooks [o.nodeName.toLowerCase ()], r && "get" en r && (n = r.get (o, "valor")) == t n:? (n = o.value, "cadena" == typeof ? n n.replace (V, ""): null == n? "": n)}}}), x.extend ({valHooks: {opción: {get: function (e) {var t = x. find.attr (e, "valor"); return null = t t:? e.text}}, seleccione: {get: function (e) {var t; a.push (t)} return a}, establezca: function (e, t) {var N | | (e.selectedIndex = -1), o}}}, attr: function (e, n, r) {var o, a, s = e.nodeType; if (e && 3 == s && 8 == s && 2! ! == s) typeof retorno o == null && (a = o.get (e, n)) a:? (a = x.find.attr (e, n), null == una camiseta: a):? == null && r o "set" en n = e.value; retorno ! i, o, a, s = e.nodeType; if (! e && 3 == s && 8 == s && 2 == s) volver a = 1 == S | | x.isXMLDoc (e), a && (n =! x.propFix [n] | |!?! n, o = x.propHooks [n]), r == t o && "set" en o && (i = o.set (e, r, n)) == t ? i: e [n] = r: o && "obtener" en o == null && (i = o.get (e, n)) i:? e [n]}, propHooks: {tabIndex: {get: function ( e) {var t = x.find.attr (e, "tabindex"); retorno r = x.expr.attrHandle [n] | | x.find.attr;? x.expr.attrHandle [n] = K && Q | | G.test (n) función (e, n, i) {var o = ?! x.expr.attrHandle [n], a = i t: (x.expr.attrHandle [n] = t) = r (e, n, i) n.toLowerCase (): null; retorno x.expr? . attrHandle [n] = o, a}: function (e, n, r) {return x.nodeName (e, "entrada") (e.defaultValue = n, t): z && z.set (e, n, r)}}), Q | | (z = {set:? función (e, n, r) {var i = e.getAttributeNode (r); retorno i; retorno r t: (i = e.getAttributeNode (n)) && "" == i.value i.value: null}, x.valHooks.button = {get: function (e, n) {?? var r = e.getAttributeNode (n); retorno e.getAttribute (t, 4)}}}), x.support.style | | (x.attrHooks.style = {get: function (e) {return e.style.cssText | | t}, establezca: function ( e, t) {return e.style.cssText = t + ""}}), x.support.optSelected | | (x.propHooks.selected = {get: function (e) {var t = e.parentNode; retorno nula === e.getAttribute ("valor") "en":? e.value})}); var él () {return 0!} function ot () {return 1!} function en el () {try {return a.activeElement} catch (e) {}} = {x.event mundial: {}, añadir: function ( e, n, r, o, a) {var typeof c [d])} else for (d en c) x.event.remove (e, d + t [u], n, r, 0);! x.isEmptyObject (c) && (borrar m.handle, x . _removeData (e, "eventos"))}}, disparador: function (n, r, i, o) {var x.Event (g, "objeto" == typeof n.result}}, despacho: function (e) {e = x.event.fix (e); var c.postDispatch && c.postDispatch.call (esto, e), e.result}}, manipuladores: function (e, n) {var n.length> l && s.push ({elem: esto, los manipuladores: n.slice (l)}), s}, fijar: function (e) {if (e [x.expando]) return e; var x.Event (o), t = r.length, mientras que (t -) n = r [t], e [n] = o [n]; retorno burbujas cancelable vista TimeStamp objetivo ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey que "split. (" "), fixHooks: {}, keyHooks: {props:." keyCode clave charCode char "split (" "), el filtro: function (e, t ) {return null == e.which && (e.which = null = t.charCode t.charCode:? t.keyCode), e}}, mouseHooks: {props: "buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement. "split (" "), el filtro: function (e, n) {var r, i, o, s = n.button, l = n.fromElement; retorno ! this.focus (), 1} catch (e) {}}, DelegateType: "focusin"}, desenfoque: {gatillo: function () {return esta === al () && this.blur (this.blur (? !), 1): t}, DelegateType: "focusOut"}, click: {gatillo: function () {return i = x.extend (nueva r = "on" + t; e.detachEvent && (typeof e [r] === i && (e [r] = null), e.detachEvent (r, n))}, x.Event = function (e, n ) {return este instanceof x.nodeName (this, "forma") 1:?! (x.event.add (this, "click._submit keypress._submit", función (e) {var n = e.target; retorno a, s, y si ("objeto" == typeof e) {"cadena" = typeof n && (r = r | | n, n = t);! para (a en e) this.on (a, n, r , e [a], o); regrese esta} if (r == null && == null i (i = n, r = n = t?): == null && i ("string" == typeof n (i =? r, r = t): (i = r, r = n, n = t)), i === 1) i = ot; else if (i) devuélvalo esta, y devuelve 1 === o && (s! = i, i = function (e) {return this.on (e, t, n, r, 1)}, off: function (e, n, r) {var i, o, si (e && e.preventDefault && e.handleObj) return e) {for (o en e) this.off (o, n, e [o]);} devolver este retorno (n === 1 | | "función" == typeof! this.each (function () {x.event.trigger (e, t, this)})}, triggerHandler: function (e, n) {var r = esta [0]; x.event.trigger retorno r (? ! e, n, r, 0): t}}); var t, n = [], r = esto, i = r.length; if (! "cadena" = typeof e) retorno n = this.pushStack (i> 1 x.unique (n):? n), n.selector = this.selector this.selector + "" + e: e, n}, tiene: function (e) {var t , n = x (e, este), r = n.length; volver this.filter (function () {for (t = 0, r> t; t + +) if (x.contains (este, n [t]) !) return 0})}, no: function (e) {return this.pushStack (ft (esto, e | | [], 0))}, Filtro: función (e) {return this.pushStack (ft ( esto, e | | [], 1))}, es: function (e) {return ft (this, "cadena" == typeof e && ut.test (e) x (e): e | | [!? !.], 1)} de longitud, el más cercano: function (e, t) {var n, r = 0, i = this.length, o = [], a = ut.test (e) | | "cadena"! = typeof this.pushStack (o.length> 1 x.unique (o): o)}, índice: función (e) {return e "cadena" == typeof ? n = "cadena" == typeof e x (e, t): x.makeArray (¿e && e.nodeType [e]: e), r = x.merge (this.get (), n); devolver esto. pushStack (x.unique (r))}, addBack: función (e) {return this.add (null == e this.prevObject:? this.prevObject.filter (e))}}); PT función de (E, t) {do e = e [l], mientras que (e && 1 == e.nodeType); vuelta de correo!} x.each ({padres: function (e) {var t = e.parentNode; retorno t && 11 == t . nodeType t: null}, los padres: function (e) {x.dir retorno (e, "parentNode")}, parentsUntil: function (e, t, n) {return x.dir (e, "parentNode", n)}, al lado: function (e) {pt retorno (e, "nextSibling")}, prev: function (e) {pt retorno (e, "previousSibling")}, nextAll: function (e) {return x. dir (e, "nextSibling")}, prevAll: function (e) {return x.dir (e, "previousSibling")}, nextUntil: function (e, t, n) {return x.dir (e, "nextSibling ", n)}, prevUntil: function (e, t, n) {return x.dir (e," previousSibling ", n)}, hermanos: function (e) {return x.sibling ((e.parentNode | | . {}) firstChild, e)}, los niños: function (e) {x.sibling retorno (e.firstChild)}, el contenido: function (e) {return i = x.map (esto, t, n); return "Hasta" == e.slice (-5) && (r = n), r && "cadena" == typeof! r = t [0]; retorno 1 === e.nodeType}))}, dir: function (e, n, r) {var i}, hermano: la función (e, t) {var n = []; for (; e; e = e.nextSibling) 1 === e.nodeType && e == t && n.push (e);}} n de retorno );! función ft (e, t, n) {if (x.isFunction (t)) return x.grep (e, función (e, r) {return T.CALL (e, r, e) = = n}); if (t.nodeType) x.grep retorno (e, función (e) {return e === t == n});! if ("string" == typeof t) {if (st . prueba (t)) x.filter retorno (t, e, n); t = x.filter (t, e)} return x.grep (e, función (e) {return x.inArray (e, t) > = 0! == dt n})} function (e) {var n} var x.access (this, function (e) {return this.domManip (argumentos, la función (e) {if (1 === this.nodeType | | 11 === this.nodeType | | 9 === this.nodeType) {var t = Lt (esto, e); t.appendChild (e)}})}, anteponga: function () {return this.domManip (argumentos, la función (e) {if (1 === this.nodeType | | 11 === this.nodeType | | 9 === this.nodeType) {var t = Lt (esto, e); t.insertBefore (e, t.firstChild)}})}, antes: function () {return this.domManip (argumentos, la función (e) {this.parentNode && esto. parentNode.insertBefore (e, this.nextSibling)})}, remover: function (e, t) {var esto}, vacía: function () {var esto}, clon:?! función (e, t) {return e = null == e 1: e, t = null == t e: t, this.map (function () {x.clone retorno (esta , e, t)})}, html: function (e) {return x.access (this, function (e) {var n = esta [0] | | {}, r = 0, i = this.length; ? si (e === t) return 1 === n.nodeType n.innerHTML.replace (gt ","): ¡t; if (("string" = typeof e = x.map (this, function (e) {return [e.nextSibling, e.parentNode]}), t = 0; volver this.domManip (argumentos, la función (n) {var this.remove (! e, 0)}, domManip: function (e, t, n) {e = d.apply ([], e); var r, i, o, a, s, l, u = 0 , c = this.length, p = esto, f = c-1, h = e [0], g = x.isFunction (h); if (g | | (1> = c | | "cadena"! = typeof h | | x.support.checkClone) && Nt.test (h)) return this.each (function (r) {var este}}); función Lt (e, t) {return Ht (e) {return e.type = (NULL! == x.find.attr (e, "tipo")) + "/" + e.type, e} qt función (e) {var t = Et. exec (e.type); retorno t e.type = t [1]:? e.removeAttribute ("tipo"), e} function _t (e, t) {var n, r = 0; for (; nulo! = (n = e [r]); r + +) x._data (n, "globalEval", T | | x._data (t [r] ", globalEval"!))} function Mt (e, t) {if (1 === t.nodeType && x.hasData (e)) {var n, r, i, o = x._data (e), a = x._data (t, o), s = o.events; if ( s) {borrar a.handle, a.events = {}; for (n en Ot (e, t) {var en this.pushStack (i)}}); función Ft (e, n) {var r, o, a = 0, s = typeof e.getElementsByTagName == i e.getElementsByTagName (n | | "*")?: typeof n === T | | n && x.nodeName (e, n) x.merge ([e], s): s} function Bt (e) {Ct.test (e.type) && (e.defaultChecked = e . marcado)} x.extend ({clon: function (e, t, n) {var Mt (e, o); retorno s = null, f}, CleanData: function (e, t) {var en a.events) f [r] x.event.remove (n, r):? x.removeEvent (n, r, a.handle);

u [o] && (¿borrar u [o], c borrar n [l]: typeof n.removeAttribute == i n.removeAttribute (l):? n [l] = null, p.push (o)) }}, _evalUrl: function (e) {return this.each (función de (t) {x (este) wrapAll (e.call (este, t)).}); si (esta [0]) {var e = este, mientras que (e.firstChild && 1 === e.firstChild.nodeType) e = e.firstChild; retorno e}) append (this)}} devuelva este, wrapInner:. función (e) {x.isFunction retorno ( ? e) this.each (function (t) {. x (este) wrapInner (e.call (esto, t))}): this.each (function () {var t = x (este), n = t contenido (); n.length n.wrapAll (e):.? t.append (e)})}, wrap: function (e) {var t = x.isFunction (E); regresan this.each (function ( n) {x (este) wrapAll (t e.call (este, n.?): e)})}, desenvuelva: function () {return tn (e, t) {if (t en e) return t;. var n = t.charAt (0) toUpperCase () + t.slice (1), r = t, i = en.length, mientras que (i -) si (t = es [i] + n, t en e) return t; retorno r} function nn (e, t) {return e = T | | e, "ninguno" === X.css ( e, "display") | |! x.contains (e.ownerDocument, rn e)} function (e, t) {var e} x.fn.extend ({css: function (e, n) {return x.access (this, function (e, n, r) {var i, o, a = {}, s = 0; if ( x.isArray (n)) {for (o = Rt (e), i = n.length; i> s;! s + +) a [n [s]] = X.css (e, n [s], 1 , o);} devolver un retorno r == t x.style (e, n, r): X.css (e, n)}, e, n, arguments.length> 1)}, espectáculo: la función? () {rn volver (esto, 0!)}, ocultar: function () {rn volver (this)}, toggle: function (e) {return "boolean" == typeof s && "get" en s && (o = s.get (e, 1, i)!) == t o: u [n]; if (a = typeof? s && (r = s.set (e, r, i)) === t))) try {u [n] = r} catch (c) {}}}, css: function (e, n, r, i) {var o, a, s, l = x.camelCase (n); retorno n = x.cssProps [l] | | (x.cssProps [l] = tn (e.style, l)), s = x.cssHooks [n] | | x.cssHooks [l], s && "get" en s && (! a = s.get (e, 0, r)), una t === && (a = Peso (e, n , i)), "normal" === a && n en e.getComputedStyle (t, null)}, Peso = function (e, n, r) {var i, o, a, s = r | | Rt (e), l = s s.getPropertyValue (n)? | | s [n]: t, u = e.style; retorno e.currentStyle}, Peso = function (e, n, r) {var i, o, a, s = r | | Rt (e), l = s s [n]: t, u = e.style; retorno en (e, t, n) {var r = Vt.exec (t); retorno r Math.max (0, r [1] - (n | | 0)) + (r [2] | | "píxeles? "): t} funciona un (e, t, n, r, i) {var a} sn función (e, t, n) {var i, r = a && (x.support.boxSizingReliable | | i === e.style [t]), i = parseFloat (i) | | 0} return i + un (e, t, n | | (a? "frontera": En función de "contenido"), r, o) + "px"} (e) {var t = a, n = Gt [e]; regreso N | | (n = un (e, t), "ninguno" == n && n | | (Pt = (Pt | | x ("<iframe frameborder='0' width='0' height='0'/>") css ("cssText", "display.: bloque html> <html> <body> "), t.close (), n = un (e, t), Pt.detach ()), Gt [e] = n), n función} un (e, t) {var n = x (t.createElement (e)) appendTo (t.body), r = X.css (n [0], "display");. retorno n.remove (), r} x.each ( ["altura", "ancho"], la función (e, n) {x.cssHooks [n] = {consiguen: la función (e, r, i) {return r 0 === e.offsetWidth && Xt.test (x . css (e, "display")) x.swap (e, Qt, function () {return sn (e, n, i)}):? sn (e, n, i): t}, establezca: función (e, t, r) {var i = r && Rt (e); retorno ? r = 0, i = {}, o = "cadena" == typeof n n.split (""): [n]; for (; 4> r, r + +) i [e + Zt [r] + t ] = o [r] | | o [r-2] | | o [0]; return i}}, Ut.test (e) | | (. x.cssHooks [e + e] juego = en)}) ; var x.param (this.serializeArray ())}, serializeArray: function () {return this.map (function () {var e = x.prop (this, "elementos"); retorno e x.makeArray (e)? : esta}) filtro (function () {var e = this.type; retorno. n = x (este) val ();. retorno for (r en e) gn (r, e [r], n, o);. volver i.join ("&") reemplazará (cn, "+")}; gn función (e, t, n, r ) {var i; si (x.isArray (t)) x.each (t, la función (t, i) {N | | pn.test (e) R (e, i): GN (E + "["? + (? "objeto" == typeof i t: "") + "]", i, n, r)}); else if (n | | "objeto" == x.type (t)) r (! e, t); más para (i en t) gn (e + "[" + i + "]", t [i], n, r)} x.each ("enfoque desenfoque focusin focusOut de cambio de tamaño de carga de desplazamiento unload clic dblclick mousedown mouseup mousemove mouseover mouseout MouseEnter mouseleave cambio seleccione Enviar keydown contextual error keyup pulsación de tecla ". split (" "), la función (e, t) {x.fn [t] = function (e, n) {return arguments.length> 0? this.on (t, null, e, n): this.trigger (t)}}), x.fn.extend. ({libración: function (e, t) {return this.mouseenter (e) mouseleave (t | | e)}, se unen: function (e, t, n) {return this.on (e, null, t, n)}, desenlazar: function (e, t) {return this.off (e, null, t)}, delegado: function (e, t, n, r) {return this.on (t, e, n, r)}, undelegate: function (e, t, n) {return 1 === argumentos. longitud this.off (e, "**"):? this.off (t, e | | "**", n)}}); mn var, yn, vn = x.now (), bn = / \ /, xn = / # * $ /, wn = / ([&?]) _ = [^ &] * /, Tn = / ^?. (*.?): [ ! Hn (e) {retorno de la función (t, n) {"cadena" = typeof t && (n = t, t = "*"); var qn (e, n, r, i) {var o = {}, a = e === jn; función s (l) {var u;! devolución o [l] = 0, x.each (e [l ] | | [], la función (e, l) {var c = l (n, r, i);??! volver "cadena" = typeof c | | a | | o [c] a (u = c !): t: (n.dataTypes.unshift (c), s (c), 1)}), u} return s (n.dataTypes [0]) | | o ["*"] && s ("* _n ")} function (e, n) {var r, i, o = x.ajaxSettings.flatOptions | | {};? for (i n) n [i] == t && ((o [i] e : R | | (r = {})) [i] = n [i]); retorno r && x.extend (0, e, r), e} x.fn.load = function (e, n, r) {if ("string" = typeof e && Sn!) devuelven Sn.apply (Esto, argumentos); var i, o, a, s = esto, l = e.indexOf (""); retorno l> = 0 && (i = ? e.slice (l, e.length), e = e.slice (0, l)), x.isFunction (n) (r = n, n = t): n && "objeto" == typeof charset = UTF-8 ", acepta: {" * ": Dn, text:" text / plain ", html:" text / html ", xml:" application / xml, text / xml ", json:" application / json , text ": String," html text ": 0," json text ": x.parseJSON," xml text ": x.parseXML}, flatOptions: {url: 0, contexto: 0}}, ajaxSetup: función (e, t) {return e && (n = e, e = t), n = n | | {}; var t, y si (2 === b) {Si {c} = {(C!); [. t [1] toLowerCase ()], mientras que (t = Tn.exec (a)) C = T [2]} t = c [e.toLowerCase ()]} devolver null == t nulo:? t}, getAllResponseHeaders: function () {return 2 === b a: null}, setRequestHeader: function (e, t) {var n = e.toLowerCase (); retorno b | | (e = v [n] = v [n] | | e, y [e] = t), esto}, overrideMimeType: function (e) {return b | | (p.mimeType = e), esto}, StatusCode: function (e) {var t; if (e) si (2> b) para (t en e) m [t] = [m [t], e [ t]]; más C.always (e [C.status]);} devolver este, abortar: function (e) {var t = e | | w; retorno p.data && (p.data = x.param (p.data, p.traditional)), qn (An, p, n, C), 2 === b) la devolución "+ Dn +"; q = 0,01 ":" "): p.accepts [" * "]); for (i en C.abort (); w = "abortar", porque (i N; k (-1, N)}} else k (-1, "No Transport"); función k (e, n, r, i) {var C}, getJSON: function (e, t, n) {x.get retorno (e, t, n, "json")}, getScript: function (e, n) {x.get retorno (e, t, n , "script")}}), x.each (["get", "mensaje"], la función (e, n) {x [n] = function (e, r, i, o) {x.isFunction retorno (r) && (o = O | | i, i = r, r = t), x.ajax ({url: e, escriba: n, tipoDatos: o, los datos: r, el éxito: i})}}) , función de Mn (e, n, r) {var en l) if (l [s] && l [s] prueba (o.)) {u.unshift (s); break} if (u [0] en r) a = u [0]; else {for (s en r) {if (u [0] | | e.converters [s + "" + u [0]]) {a = s;! break} I | | (i = s)} a = a | | i} devolver un (a! == u [0] && u.unshift (a), r [a]):? t} function On (e, t, n, r) {var i, o, a, s, l, u = {}, c = e.dataTypes.slice (); if (c [1]) para (a en if ("*" == l && l == o!!) {if (a = u [l + "" + o] | | u! ["*" + o], a) para (i en u) if (s = i.split (""), s [1] === o && (a = u [l + "" + s [0]] | | u ["* try {t = a (t)} catch (p) {return {estado: "ParserError", error:? una p: "Sin la conversión de" + l + "a" + o}}} return {estado: "el éxito" , los datos: t}} x.ajaxSetup ({acepta: {script: "text / javascript, application / javascript, application / ecmascript, application / x-ecmascript"}, contenido: {guión :/ (:? java | ecma) script /}, convertidores: {"script de texto": function (e) {return Fn = [], Bn = / (=) \ \ \ /; x.ajaxSetup ({jsonp? (= & | | $?): "Callback", jsonpCallback: function () {var e = Fn.pop? () | | x.expando + "_" + vn + +;! devolver este [e] = 0, e}}), x.ajaxPrefilter ("json jsonp", función (n, r, i) {var O, A, s, l = n.jsonp == 1 && (Bn.test (n.url) "url":!!? "cadena" == typeof json "] = function () {return s | | x.error (o +" no era Pn, Rn, Wn = 0, $ n = e.ActiveXObject && function () {var e; para (e en Pn) Pn [e] (t, 0!)}; Función In () {try {return new e.XMLHttpRequest } catch (t) {}} function zn () {try {return new Rn, Rn = x.support.ajax = Rn, Rn && x.ajaxTransport (function (n) {if (n.crossDomain | | x.support.cors) {var r; retorno {enviar: ¡¡¡la función (i, o ) {var en en i) l.setRequestHeader (s, i [s])} catch (u) {} l.send (n.hasContent && n.data | | null), r = function (e, i) {var s, u, c , p; try {if (r && (i | | 4 === l.readyState)) if (r = t, a && (l.onreadystatechange = x.noop, $ n && eliminar s = s | | "0,5", a / = s, x.style (n.elem, e, a + o);! while (s! == (s = n.cur () / r) && 1 = = s && - l)} return i && (¿a = n.start = + a | | + r | | 0, n.unit = o, n.end = i [1] a + (i [1] 1) * i [2]: + i [2]), n}]}; función Kn () {return setTimeout (function () {Xn = t}), Xn = x.now)} function (Zn (e, t , n) {var r, i = (Qn [t] | | []) concat (Qn ["*"]), o = 0, a = i.length;. for (; a> o; o + +) si (r = i [o]. llamada (n, t, e)) return r} function er (e, t, n) {var r, i, o = 0, a = Gn.length, s = x.Deferred () siempre (function () {borrar l.elem}), l = function () {if (i) return 1;.! var r = x.Tween (e, u.opts, t, n, u.opts.specialEasing [t] | | u.opts.easing); volver u.tweens.push (r), r}, parada: la función ( t) {var n = 0, r = t u.tweens.length: 0; si (i) devolver este; for (i = 0; r> n, n + +) u.tweens [n] correr (1!. ); retorno r; retorno tr (e, t) {var n, r, i, o, a; para (n en e) si (r = x.camelCase (n), i = t [r], o = e [n], x . isArray (o) && (i = o [1], o = e [n] = o [0]), n! == r && (e [r] = o, borrar e [n]), a = x . cssHooks [r], a && "ampliar" en a) {o = a.expand (o), eliminar e [r]; para (n en o) n en e | | (e [n] = o [n] , t [n] = i)} else t [r] = i} = x.Animation x.extend? (er, {tweener: function (e, t) {x.isFunction (e) (t = e, e = ["*"]): e = e.split (""); var nr (e, t, n) {var t | | "ancho" en en t) si (i = t [r], Vn.exec (i)) {if (eliminar t; x._removeData (e, "fxshow"), para (t en c) x.style (e, t, c [t])}); para (r in c) a = Zn (f d [r? ]: 0, r, u), r en d | | (d [r] = a.Inicie, f "ancho" && (a.end = a.Inicie, a.Inicie = === r | | "altura" === r? 1:0))}} function rr (e, t, n, r, i) {return new ? e = rr.propHooks [this.prop]; regresar e && e.get e.get (este): rr.propHooks._default.get (this)}, ejecute: function (e) {var t, n = rr.propHooks [this.prop]; retorno t; retorno n = x.fn [t]; x.fn [t] = function (e, r, i) {return null == e | | "boolean" == typeof i = x.isEmptyObject (e), o = x.speed (t, n, r), a = function () {var t = er (esto, x.extend ({}, e), o), (i | | x._data (this, "finish")) && t.stop (0)}; retorno a.finish = a, i | | o.queue === 1 this.each (a): esto!?. cola (o.queue, a)}, pare: function (e, n, r) {var i = function (e) {var t = e.stop; eliminar e.stop, t (r)}; volver "string "(| fx", [] = typeof e && (r = n, n = e, e = t), n && e == 1 && this.queue e |)! ", this.each (function () {var t = !! 0, n = nulo = E && e + "queueHooks", o = x.timers, a = x._data (this);. if (n) a [n] && a [n] detienen && i (a [n]); más for (n en ¡e == 1 && (e = e | | "fx"), this.each (function () {var n.finish})}}); ir función (e, t) {var n, r = {height: e}, i = 0; para (t = t 1:00; 4> i; i + = 2 - t) n = Zt [i], r ["margen" + n] = r ["relleno" + n] = e; retorno this.animate (t, e, n, r)}}), x.speed = function (e, t, n) {var r = e && "objeto" == typeof ? r.duration = x.fx.off 0: "número" == r.duration typeof r.duration:? r.duration en x.fx.speeds x.fx.speeds [r.duration]: x.fx . velocidades.

x.grep (x.timers, función (t) {return e === t.elem}). longitud}), x.fn.offset = function (e) {if (arguments.length) vuelta de correo === ? t esto: this.each (function (t) {x.offset.setOffset (este, e, t)}); var n, r, o = {top: 0, izquierda: 0}, a = esta [0 ], s = a && a.ownerDocument; if (s) return n = s.documentElement, x.contains (n, a) (typeof? r = X.css (e, "posición"), "estática" === r && (e.style.position = "relativa"); var ? t.using.call t (e, u): i.css (u)}}, x.fn.extend ({position: function () {if (esto [0]) {var this.map (function () {var e | | s})}}), x.each ({scrollLeft: "pageXOffset", scrollTop: "pageYOffset"}, función (e, n) {var r = / Y / .test (n); x.fn [e] = function (i) {return x.access (this, function (e, i, o) {var a = o (e); volver o === t a n en? o (e) {return a = arguments.length && (r | | "boolean" = typeof i!), s = r | | (i === 0 | | o === 0 "margen":!!? "frontera"); volver x . acceso (esto, la función (n, r, i) {var o; retorno this.length}, x.fn.andSelf = x.fn.addBack, "objeto" == typeof módulo && módulo && "objeto" == typeof module.exports module.exports = x:?. (e.jQuery = E $ = x , "función" == typeof definir && define.amd && define ("jquery", [], function () {return x}))}) (ventana);